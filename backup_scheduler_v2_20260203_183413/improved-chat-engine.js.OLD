/**
 * Improved AI Chat Engine
 * Replaces problematic seed data with fact-based responses
 * Integrates interview scheduling for pending candidates
 */

const SLMSchedulingBridge = require('../../utils/slm-scheduling-bridge');
const Database = require('better-sqlite3');
const path = require('path');

class ImprovedChatEngine {
  constructor() {
    const dbPath = path.resolve(__dirname, '../../db/database.db');
    this.db = new Database(dbPath);
    this.slmBridge = new SLMSchedulingBridge();

    // Consultant reference variations for natural conversation
    this.consultantReferences = [
      'our friendly consultant',
      'our consultant',
      'our team lead',
      'our senior consultant',
      'our recruitment consultant',
      'one of our consultants'
    ];

    // Initialize improved response system
    this.initializeFactBasedResponses();
  }

  getConsultantReference() {
    // Return a random consultant reference for natural variation
    const randomIndex = Math.floor(Math.random() * this.consultantReferences.length);
    return this.consultantReferences[randomIndex];
  }

  initializeFactBasedResponses() {
    // Fact-based FAQ responses that DON'T make false promises
    this.factBasedFAQ = {
      payment_timing: {
        patterns: ['payment', 'pay', 'when', 'money', 'salary', 'wage'],
        response: (realData) => {
          if (realData?.pendingEarnings > 0) {
            return `I can see you have $${realData.pendingEarnings.toFixed(2)} in pending earnings. Payment timing depends on job completion and client approval - I'll check with the admin team on the specific timeline for your jobs.`;
          }
          return "Payment timing varies by job type and client. Let me get the admin team to check your specific situation and provide accurate timing.";
        },
        requiresRealData: true
      },

      account_verification: {
        patterns: ['verify', 'verification', 'approve', 'approval', 'pending', 'review'],
        response: (realData, candidateInfo) => {
          if (candidateInfo?.status === 'pending') {
            return `I understand you're waiting for account verification. Would you like me to help schedule a verification interview with ${this.getConsultantReference()}? This can speed up the process significantly! Just let me know your availability.`;
          }
          return "Your account appears to be active. If you're having verification issues, I'll flag this for the admin team to review.";
        },
        requiresRealData: false
      },

      job_availability: {
        patterns: ['job', 'work', 'opportunity', 'available', 'hiring'],
        response: (realData) => {
          if (realData?.upcomingJobs?.length > 0) {
            return `You have ${realData.upcomingJobs.length} upcoming job(s) scheduled. Check your Jobs tab for details and timing.`;
          }
          return "I'll have the admin team check for current job opportunities that match your profile and location.";
        },
        requiresRealData: true
      },

      withdrawal_process: {
        patterns: ['withdraw', 'withdrawal', 'cash out', 'transfer'],
        response: (realData) => {
          if (realData?.availableEarnings > 0) {
            return `You have $${realData.availableEarnings.toFixed(2)} available for withdrawal. The admin team handles withdrawal processing - I'll flag your request for priority review.`;
          }
          return "I'll check with the admin team about the current withdrawal process and any requirements.";
        },
        requiresRealData: true
      },

      technical_support: {
        patterns: ['bug', 'error', 'problem', 'issue', 'not working'],
        response: () => {
          return "I've flagged this technical issue for immediate admin attention. Please describe the specific problem you're experiencing so they can assist you properly.";
        },
        requiresRealData: false
      }
    };

    // Escalation triggers for admin attention
    this.escalationTriggers = [
      'urgent', 'emergency', 'complaint', 'angry', 'frustrated',
      'cancel', 'refund', 'dispute', 'unfair', 'wrong'
    ];
  }

  /**
   * Main chat processing function
   * Replaces the existing problematic system
   */
  async processMessage(candidateId, message, adminMode = 'auto') {
    try {
      console.log(`ðŸ¤– Processing message for candidate ${candidateId}: ${message.substring(0, 50)}...`);

      // Get candidate information
      const candidate = await this.getCandidateInfo(candidateId);

      if (!candidate) {
        return this.generateErrorResponse('candidate_not_found');
      }

      // PRIORITY 1: Handle pending candidates with interview scheduling
      if (candidate.status === 'pending') {
        console.log(`ðŸŽ¯ Pending candidate detected - routing to interview scheduling`);
        return await this.handlePendingCandidateWithScheduling(candidateId, message, candidate);
      }

      // PRIORITY 2: Check for escalation triggers
      if (this.needsEscalation(message)) {
        console.log(`ðŸš¨ Escalation trigger detected`);
        return this.generateEscalationResponse(candidate, message);
      }

      // PRIORITY 3: Get real data for context
      const realData = await this.getRealCandidateData(candidateId);

      // PRIORITY 4: Try fact-based FAQ matching
      const faqResponse = this.matchFactBasedFAQ(message, realData, candidate);
      if (faqResponse) {
        console.log(`ðŸ“š Fact-based FAQ match found`);
        return faqResponse;
      }

      // PRIORITY 5: Generate LLM response with real data context
      return await this.generateLLMResponse(message, realData, candidate);

    } catch (error) {
      console.error('âŒ Chat processing error:', error);
      return this.generateErrorResponse('processing_error');
    }
  }

  /**
   * Handle pending candidates with interview scheduling integration
   */
  async handlePendingCandidateWithScheduling(candidateId, message, candidate) {
    try {
      // Use SLM scheduling bridge for intelligent interview booking
      const schedulingResponse = await this.slmBridge.handlePendingCandidateMessage(
        candidateId,
        message,
        { platform: 'admin_chat' }
      );

      if (schedulingResponse) {
        return {
          content: schedulingResponse.content,
          source: 'interview_scheduling',
          confidence: 0.95,
          intent: schedulingResponse.type,
          metadata: schedulingResponse.metadata,
          isPendingUser: true,
          canScheduleInterview: true
        };
      }

      // Fallback to enhanced pending response
      return this.generateEnhancedPendingResponse(candidate, message);

    } catch (error) {
      console.error('âŒ Interview scheduling error:', error);
      return this.generateEnhancedPendingResponse(candidate, message);
    }
  }

  /**
   * Generate enhanced pending response (fallback)
   */
  generateEnhancedPendingResponse(candidate, message) {
    const firstName = candidate.name.split(' ')[0];
    const consultantRef = this.getConsultantReference();

    // Check message intent for better responses
    if (this.containsPatterns(message, ['job', 'work', 'opportunity'])) {
      return {
        content: `Hi ${firstName}! Your account is being reviewed for job opportunities. To speed up the process, I can help schedule a quick verification interview with ${consultantRef}. This usually fast-tracks approval within 24-48 hours. Would you like me to find a good time slot for you?`,
        source: 'enhanced_pending',
        confidence: 0.9,
        intent: 'pending_job_inquiry'
      };
    }

    if (this.containsPatterns(message, ['when', 'how long', 'time'])) {
      return {
        content: `Hi ${firstName}! Account verification typically takes 2-3 business days. However, I can help speed this up by scheduling a 15-minute verification interview with ${consultantRef}. This often leads to same-day approval! Would you like me to check available time slots?`,
        source: 'enhanced_pending',
        confidence: 0.9,
        intent: 'pending_timing_inquiry'
      };
    }

    return {
      content: `Hi ${firstName}! Your account is under review by our team. While you wait, I can help fast-track the process by scheduling a quick verification interview with ${consultantRef}. This usually speeds up approval significantly! Just let me know if you'd like me to find a good time for you. ðŸ“…`,
      source: 'enhanced_pending',
      confidence: 0.85,
      intent: 'pending_general'
    };
  }

  /**
   * Get real candidate data (replacing unreliable seed data)
   */
  async getRealCandidateData(candidateId) {
    try {
      // Get real payment data
      const payments = this.db.prepare(`
        SELECT
          SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as pendingEarnings,
          SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as paidEarnings,
          SUM(CASE WHEN status = 'available' THEN amount ELSE 0 END) as availableEarnings
        FROM payments WHERE candidate_id = ?
      `).get(candidateId);

      // Get real job data
      const jobs = this.db.prepare(`
        SELECT * FROM jobs
        WHERE assigned_candidate_id = ?
        AND scheduled_date >= DATE('now')
        ORDER BY scheduled_date
      `).all(candidateId);

      // Get recent activity
      const activity = this.db.prepare(`
        SELECT * FROM candidate_activity
        WHERE candidate_id = ?
        ORDER BY created_at DESC
        LIMIT 5
      `).all(candidateId);

      return {
        pendingEarnings: payments?.pendingEarnings || 0,
        paidEarnings: payments?.paidEarnings || 0,
        availableEarnings: payments?.availableEarnings || 0,
        upcomingJobs: jobs || [],
        recentActivity: activity || []
      };

    } catch (error) {
      console.error('Error getting real candidate data:', error);
      return null;
    }
  }

  /**
   * Match fact-based FAQ (replacing problematic seed data)
   */
  matchFactBasedFAQ(message, realData, candidate) {
    const messageLower = message.toLowerCase();

    for (const [category, faq] of Object.entries(this.factBasedFAQ)) {
      if (this.containsPatterns(messageLower, faq.patterns)) {
        const responseData = faq.requiresRealData ? realData : null;
        const content = faq.response(responseData, candidate);

        return {
          content,
          source: `fact_based_faq_${category}`,
          confidence: 0.85,
          intent: category,
          usesRealData: faq.requiresRealData
        };
      }
    }

    return null;
  }

  /**
   * Check if message needs escalation to admin
   */
  needsEscalation(message) {
    const messageLower = message.toLowerCase();
    return this.escalationTriggers.some(trigger => messageLower.includes(trigger));
  }

  /**
   * Generate escalation response
   */
  generateEscalationResponse(candidate, message) {
    const firstName = candidate.name.split(' ')[0];

    return {
      content: `Hi ${firstName}, I understand this is important to you. I've flagged your message for immediate admin attention and they'll respond personally within the next few hours. Thank you for your patience.`,
      source: 'escalation',
      confidence: 1.0,
      intent: 'escalate_to_admin',
      requiresAdminAttention: true,
      escalated: true
    };
  }

  /**
   * Generate LLM response with real data context (improved prompting)
   */
  async generateLLMResponse(message, realData, candidate) {
    try {
      // Build context with REAL data only
      let context = `REAL CANDIDATE DATA for ${candidate.name}:\n`;

      if (realData) {
        context += `- Pending Earnings: $${realData.pendingEarnings?.toFixed(2) || '0.00'}\n`;
        context += `- Paid Earnings: $${realData.paidEarnings?.toFixed(2) || '0.00'}\n`;
        context += `- Available for Withdrawal: $${realData.availableEarnings?.toFixed(2) || '0.00'}\n`;
        context += `- Upcoming Jobs: ${realData.upcomingJobs?.length || 0}\n`;
      }

      context += `\nCandidate Status: ${candidate.status}\n`;
      context += `\nCandidate Message: "${message}"\n`;

      const improvedPrompt = `You are WorkLink's AI assistant. You must ONLY use the REAL DATA provided above.

STRICT RULES:
1. NEVER make promises about timing you cannot guarantee
2. NEVER claim automatic processes that don't exist
3. NEVER state specific timeframes unless they're in the real data
4. If you don't have specific information, say "I'll check with the admin team"
5. Always base responses on the REAL DATA provided
6. Be helpful but honest about limitations

Examples of GOOD responses:
- "I can see you have $X in pending earnings. Let me check with the admin team on the timeline."
- "I'll flag this for admin review to get you accurate information."
- "Based on your account, I can see... Let me have the team follow up on specifics."

Examples of BAD responses:
- "Funds will arrive in 24 hours" (false promise)
- "The system will auto-approve" (doesn't exist)
- "Withdrawals are free" (might not be true)

Respond to the candidate's message using ONLY the real data provided:`;

      // Call your existing LLM (Claude) with improved prompt
      const response = await this.callLLMWithContext(improvedPrompt, context);

      return {
        content: response,
        source: 'llm_with_real_data',
        confidence: 0.8,
        intent: 'general_inquiry',
        usesRealData: true
      };

    } catch (error) {
      console.error('LLM generation error:', error);
      return {
        content: "I'm having trouble processing your request right now. I've flagged this for admin attention and they'll get back to you soon.",
        source: 'llm_error_fallback',
        confidence: 0.7,
        intent: 'error_fallback'
      };
    }
  }

  /**
   * Helper methods
   */

  async getCandidateInfo(candidateId) {
    return this.db.prepare('SELECT * FROM candidates WHERE id = ?').get(candidateId);
  }

  containsPatterns(text, patterns) {
    return patterns.some(pattern => text.toLowerCase().includes(pattern.toLowerCase()));
  }

  async callLLMWithContext(prompt, context) {
    // Integration with your existing Claude LLM call
    // This would call your existing askClaude function
    try {
      const { askClaude } = require('./index'); // Your existing LLM integration
      return await askClaude(prompt + '\n\n' + context);
    } catch (error) {
      throw error;
    }
  }

  generateErrorResponse(errorType) {
    const errorMessages = {
      candidate_not_found: "I'm sorry, I couldn't find your profile. Please contact support.",
      processing_error: "I'm experiencing technical difficulties. I've flagged this for admin attention."
    };

    return {
      content: errorMessages[errorType] || errorMessages.processing_error,
      source: 'error_response',
      confidence: 1.0,
      intent: 'error',
      error: true
    };
  }

  /**
   * Integration method for existing chat system
   */
  async replaceExistingChatLogic(candidateId, message, adminMode = 'auto') {
    // This completely replaces the problematic existing logic
    return await this.processMessage(candidateId, message, adminMode);
  }
}

module.exports = ImprovedChatEngine;
